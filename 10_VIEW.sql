-- 0412
-- ORACLE에서 제공하는 OBJECT활용하기
-- USER, TABLE, VIEW, SEQUENCE, INDEX, SYNONYM, FUNCTION, PROCEDURE, PACKAGE 등

-- VIEW에 대해 알아보자
-- SELECT문의 결과 RESULT SET을 하나의 테이블처럼 활용하게 하는 것
-- STORED VIEW 생성하기
-- CREATE  [옵션] VIEW 뷰명칭 AS SELECT문
CREATE VIEW V_EMP
AS SELECT * FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;

-- VIEW를 생성할 권한을 부여해야 한다.
-- SYSTEM / SYS AS SYSDBA(최고 관리자) 계정으로 부여를 한다.
GRANT CREATE VIEW TO BS;

CREATE VIEW V_EMP
AS SELECT * FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;

-- 생성된 TABLE 이용하기
SELECT * FROM V_EMP;

-- 부서별, 직책별 급여의 평균을 구하는 SELECT문
SELECT DEPT_CODE, AVG(SALARY) FROM EMPLOYEE GROUP BY DEPT_CODE;
SELECT JOB_CODE, AVG(SALARY) FROM EMPLOYEE GROUP BY JOB_CODE;

SELECT DEPT_CODE, AVG(SALARY) FROM EMPLOYEE GROUP BY DEPT_CODE
UNION
SELECT JOB_CODE, AVG(SALARY) FROM EMPLOYEE GROUP BY JOB_CODE;

CREATE VIEW V_AVG_DEPTJOB
AS
SELECT DEPT_CODE, AVG(SALARY) AS AVG_SALARY FROM EMPLOYEE GROUP BY ROLLUP(DEPT_CODE)
UNION
SELECT JOB_CODE, AVG(SALARY) FROM EMPLOYEE GROUP BY ROLLUP(JOB_CODE);

SELECT * FROM V_AVG_DEPTJOB
WHERE AVG_SALARY >= 3000000 AND DEPT_CODE IS NOT NULL;

-- WITH VS VIEW
--   WITH는 ; 끝나면 못씀
--   VIEW는 SELECT문 한 번 저장하면 쭉 쓸 수 있음

-- VIEW 테이블 조회
SELECT * FROM USER_VIEWS;

-- VIEW의 특징
-- DML구문은 사용이 가능하니?
-- 실제 테이블과 연결되어 있는 컬럼을 수정할 때는 가능, 가상컬럼은 수정이 불가능하다.

-- 1. UPDATE
SELECT * FROM V_EMP;
UPDATE V_EMP SET EMP_NAME = '최주영' WHERE EMP_NAME = '월드컵';
SELECT * FROM EMPLOYEE; -- VIEW테이블을 수정했지만 실제 테이블에서도 DML로 수정됨
UPDATE V_AVG_DEPTJOB SET AVG_SALARY = 1000000; -- X, 가상컬럼은 DML로 수정 불가능

-- 2. INSERT
-- 단일 테이블로 만들어진 VIEW는 INSERT가 가능함.
-- -> VIEW에서 값을 넣은 것 이외에 컬럼에는 NULL값을 삽입함 -> NOT NULL 제약조건이 설정되면 안된다.
CREATE VIEW V_EMPTEST
AS SELECT EMP_ID, EMP_NO, EMP_NAME, EMAIL, PHONE, JOB_CODE, SAL_LEVEL FROM EMPLOYEE;
--SELECT DEPT_CODE FROM V_EMPTEST;
INSERT INTO V_EMPTEST VALUES ('997', '981011-1234123', '홍길동', 'HONG@HONG.COM', '12341234', 'J1', 'S1');

-- JOIN을 사용한 VIEW는 INSERT가 불가능함.
-- JOIN, UNION 연결된 VIEW는 입력이 불가능함.
INSERT INTO V_EMP VALUES('996', '홍길동', '980110-1234567', 'HONG@HONG.COM', '12345', 'D5', 'J1', 'S1', 100, 0.2, 206, SYSDATE,
                                            NULL, 'N', 'D0', '되니', 'L3'); -- X, 조인 뷰에 의하여 하나 이상의 기본 테이블을 수정할 수 없습니다.
                                            
-- 3. DELETE                                            
-- DELETE 문은 가능하니? 가능하다.
DELETE FROM V_EMPTEST WHERE EMP_ID = '997';
SELECT * FROM EMPLOYEE; -- 실제 테이블에서도 삭제됨
DELETE FROM V_EMP WHERE EMP_NAME = '옛사람'; -- JOIN이어도 DELETE는 가능

-- VIEW 생성 시 사용할 수 있는 옵션
-- 1. OR REPLACE : 중복되는 VIEW이름이 있으면 덮어쓰기를 해주는 옵션
--      * OBJECT명칭은 중복이 불가능하다.
CREATE VIEW V_EMP
AS SELECT * FROM EMPLOYEE; -- X, 기존의 객체가 이름을 사용하고 있습니다.

CREATE OR REPLACE VIEW V_EMP
AS SELECT * FROM EMPLOYEE;  -- O, 덮어쓰기(JOIN했던 DEPARTMENT 사라짐)

SELECT * FROM V_EMP;

-- 2. FORCE/NOFORCE : 실제 테이블이 존재하지 않아도 VIEW를 생성할 수 있게 해주는 옵션
SELECT * FROM TT; -- 없는 테이블
CREATE OR REPLACE VIEW V_TT
AS SELECT * FROM TT; -- X

CREATE FORCE VIEW V_TT
AS SELECT * FROM TT; -- O

SELECT * FROM V_TT; -- 조회는 불가능, 아래 테이블 생성 후 조회 가능

CREATE TABLE TT(
    TTNO NUMBER,
    TTNAME VARCHAR2(200)
);

-- 3. WITH CHECK OPTION : SELECT문의 WHERE절에 사용한 컬럼은 수정하지 못하게 만드는 옵션
CREATE OR REPLACE VIEW V_CHECK
AS SELECT EMP_ID, EMP_NAME, SALARY, DEPT_CODE
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5' WITH CHECK OPTION;

SELECT * FROM V_CHECK; -- 하이유가 D6으로 바뀌면서 하이유 ROW 출력 안됨(WITH CHECK OPTION 없을 때)
UPDATE V_CHECK SET DEPT_CODE = 'D6' WHERE EMP_NAME = '하이유'; -- WITH CHECK OPTION 설정하면 오류 발생
UPDATE V_CHECK SET EMP_NAME = '김재훈' WHERE EMP_NAME = '하이유'; -- WHERE절 컬럼이 아니기때문에 수정 가능
ROLLBACK;

-- 4. WITH READ ONLY : VIEW 테이블에서 수정을 불가능하게 하는 옵션 -> 읽기 전용
CREATE OR REPLACE VIEW V_CHECK
AS SELECT EMP_ID, EMP_NAME, SALARY, DEPT_CODE
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5' WITH READ ONLY;