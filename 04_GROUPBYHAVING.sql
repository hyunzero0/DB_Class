-- GROUP BY 절 활용하기
-- 그룹함수를 사용했을 때 특정기준으로 컬럼값을 묶어서 처리하는 것 -> 묶인 그룹별 그룹함수의 결과가 출력됨
-- SELECT 컬럼명
-- FROM 테이블명
-- [WHERE 조건식]
-- [GROUP BY 컬럼명 [, 컬럼명, 컬럼명, ...] ]
-- [ORDER BY 컬럼명]

-- 부서별 급여 합계를 구하시오
SELECT DEPT_CODE,0 SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE;

-- 직책별 급여의 합계, 평균을 구하시오
SELECT JOB_CODE, SUM(SALARY), AVG(SALARY)
FROM EMPLOYEE
GROUP BY JOB_CODE;

-- 부서별 사원수 구하기
SELECT DEPT_CODE, COUNT(*)
FROM EMPLOYEE
GROUP BY DEPT_CODE;

-- GROUP BY 절에는 다수의 컬럼을 넣을 수 있다.
SELECT DEPT_CODE, JOB_CODE, COUNT(*)
FROM EMPLOYEE
GROUP BY DEPT_CODE, JOB_CODE;

-- GROUP BY를 사용한 절에서 WHERE도 사용 가능
SELECT DEPT_CODE, SUM(SALARY), COUNT(*)
FROM EMPLOYEE
WHERE BONUS IS NOT NULL
GROUP BY DEPT_CODE;

-- 부서별 인원이 3명 이상인 부서만 출력하기
SELECT DEPT_CODE, COUNT(*)
FROM EMPLOYEE
--WHERE COUNT(*) >= 3 -- WHERE절에는 그룹함수 사용X
GROUP BY DEPT_CODE
HAVING COUNT(*) >= 3;

-- 직책 별 인원 수가 3명 이상인 직책 출력
SELECT JOB_CODE, COUNT(*)
FROM EMPLOYEE
GROUP BY JOB_CODE
HAVING COUNT(*) >= 3;

-- 평균급여가 300만원 이상인 부서 출력하기
SELECT DEPT_CODE, AVG(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING AVG(SALARY) >= 3000000;

-- 매니저가 관리하는 사원이 2명 이상인 매니저 아이디 출력하기
SELECT MANAGER_ID, COUNT(*)
FROM EMPLOYEE
WHERE MANAGER_ID IS NOT NULL
GROUP BY MANAGER_ID
HAVING COUNT(*) >= 2;

-- 남자, 여자의 급여 평균을 구하고 인원 수 구하기
SELECT DECODE(SUBSTR(EMP_NO, 8, 1), '1', '남', '3', '남', '2', '여', '4', '여') AS 성별, AVG(SALARY), COUNT(*)
FROM EMPLOYEE
GROUP BY DECODE(SUBSTR(EMP_NO, 8, 1), '1', '남', '3', '남', '2', '여', '4', '여');

--0404
-- 각 그룹별 집계와 총 집계를 한번에 출력해주는 함수
-- ROLLUP(), CUBE()
-- GROUP BY ROLLUP(컬럼명)
-- GROUP BY CUBE(컬럼명)

-- 부서별 급여합계와 총 합계를 조회하는 구문
SELECT SUM(SALARY) -- 총 합계
FROM EMPLOYEE;

SELECT DEPT_CODE, SUM(SALARY) -- 부서별 급여합계
FROM EMPLOYEE
WHERE DEPT_CODE IS NOT NULL
GROUP BY DEPT_CODE;

SELECT DEPT_CODE, SUM(SALARY) -- ROLLUP 합계 아래에
FROM EMPLOYEE
WHERE DEPT_CODE IS NOT NULL
GROUP BY ROLLUP(DEPT_CODE);

SELECT DEPT_CODE, SUM(SALARY) -- CUBE 합계 위에
FROM EMPLOYEE
WHERE DEPT_CODE IS NOT NULL
GROUP BY CUBE(DEPT_CODE);

SELECT JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
--GROUP BY ROLLUP(JOB_CODE);
GROUP BY CUBE(JOB_CODE);

-- ROLLUP, CUBE 함수의 인수로 한 개 이상의 컬럼을 넣을 수 있다
-- ROLLUP : 두 개 이상의 인수를 전달했을 때 두 개 컬럼의 집계, 첫 번째 인수컬럼의 소계, 전체 총계
-- CUBE : 두 개 이상 인수를 전달했을 때 두 개 컬럼의 집계, 첫 번째 인수컬럼의 소계, 두 번째 인수컬럼의 소계, 전체 총계

SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
WHERE DEPT_CODE IS NOT NULL
GROUP BY ROLLUP(DEPT_CODE, JOB_CODE);

SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
WHERE DEPT_CODE IS NOT NULL
GROUP BY CUBE(DEPT_CODE, JOB_CODE);

-- 부서별, 직책별, 총 사원을 한번에 조회하기
SELECT DEPT_CODE, JOB_CODE, COUNT(*)
FROM EMPLOYEE
WHERE DEPT_CODE IS NOT NULL
GROUP BY CUBE(DEPT_CODE, JOB_CODE);

-- GROUPING 함수를 이용하면 집계한 결과에 대한 분기처리를 할 수 있다.
-- ROLLUP, CUBE로 집계된 ROW에 대한 분기처리
-- GROUPING 함수를 실행하면 ROLLUP, CUBE로 집계된 ROW 1을 반환 아니면 0을 반환
SELECT DEPT_CODE, JOB_CODE, COUNT(*),
        CASE
                WHEN GROUPING(DEPT_CODE) = 0 AND GROUPING(JOB_CODE) = 1 THEN '부서별 인원'
                WHEN GROUPING(DEPT_CODE) = 1 AND GROUPING(JOB_CODE) = 0 THEN '직책별 인원'
                WHEN GROUPING(DEPT_CODE) = 0 AND GROUPING(JOB_CODE) = 0 THEN '부서_직책별 인원'
                WHEN GROUPING(DEPT_CODE) = 1 AND GROUPING(JOB_CODE) = 1 THEN '총 인원'
        END AS 결과
FROM EMPLOYEE
WHERE DEPT_CODE IS NOT NULL
GROUP BY CUBE(DEPT_CODE, JOB_CODE);

-- 테이블에서 조회한 데이터 정렬하기
-- ORDER BY 구문을 사용함
-- SELECT 컬럼명...
-- FROM 테이블명
-- [WHERE 조건식]
-- [GROUP BY 컬럼명]
-- [HAVING 조건식]
-- [ORDER BY 컬럼명 정렬방식(DESC(내림), ACS(오름, DEFAULT)) ] / 오름이면 생략가능

-- 이름을 기준으로 정렬하기
SELECT *
FROM EMPLOYEE
ORDER BY EMP_NAME;

SELECT *
FROM EMPLOYEE
ORDER BY EMP_NAME DESC;

-- 월급이 높은 사람부터 낮은 사람으로 정렬하기
-- 이름, 급여, 보너스
SELECT EMP_NAME, SALARY, BONUS
FROM EMPLOYEE
ORDER BY SALARY DESC;

-- 부서코드를 기준으로 오름차순 정렬하고 값이 같으면 월급 내림차순으로 정렬하기
SELECT *
FROM EMPLOYEE
ORDER BY DEPT_CODE ASC, SALARY DESC, EMP_NAME ASC;

-- 정렬했을 때 NULL값에 대한 처리
-- BONUS를 많이 받는 사원부터 출력하기
SELECT *
FROM EMPLOYEE
--ORDER BY BONUS DESC; -- NULL인 값을 먼저 출력
--ORDER BY BONUS ASC; -- NULL인 값을 나중에 출력
-- 옵션을 설정해서 NULL값 출력위치를 변경할 수 있다.
--ORDER BY BONUS DESC NULLS LAST; -- NULL 마지막으로
ORDER BY BONUS ASC NULLS FIRST; -- NULL 처음으로

-- ORDER BY절에서는 별칭을 사용할 수 있다.
SELECT EMP_NAME, SALARY AS 월급, BONUS
FROM EMPLOYEE
ORDER BY 월급;

-- SELECT문을 이용해서 데이터를 조회하면 RESULT SET이 출력되는데
-- RESULT SET에 출력되는 컬럼에는 자동으로 INDEX번호가 1부터 부여가 됨
SELECT *
FROM EMPLOYEE
ORDER BY 2; -- 1 : EMP_ID, 2 : EMP_NAME ...

-- 집합연산자
-- 여러 개의 SELECT문을 한 개의 결과(RESULT SET)으로 출력해주는 것
-- 조건 1 : 첫 번째 SELECT문의 컬럼 수와 이후 SELECT문의 컬럼 수가 같아야한다.
-- 조건 2 : 각 컬럼별 데이터 타입도 동일해야 한다.

-- UNION : 두 개 이상의 SELECT문을 합치는 연산자
-- SELECT문 UNION SELECT문
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION -- 중복값 미포함
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY >= 3000000;

SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION ALL -- 중복값 포함
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY >= 3000000;

SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
MINUS -- 중복값 제거 후 출력
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY >= 3000000;

SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
INTERSECT -- 중복값만 출력
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY >= 3000000;

-- 두 SELECT문의 컬럼이 다르면 안된다.
SELECT EMP_ID, EMP_NAME, SALARY -- 컬럼 3
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION
--SELECT EMP_ID, EMP_NAME, SALARY, BONUS -- X 컬럼 4
--FROM EMPLOYEE
--WHERE SALARY > 3000000;
-- 두 개의 SELECT문의 컬럼의 타입도 맞춰야한다.
SELECT EMP_ID, EMP_NAME, EMP_NO -- X 컬럼 3, 컬럼명 다름 
FROM EMPLOYEE
WHERE SALARY >= 3000000;

-- 다른 테이블에 있는 데이터를 합치기
SELECT EMP_ID, EMP_NAME, SALARY
FROM EMPLOYEE
UNION 
SELECT DEPT_ID, DEPT_TITLE ,10
FROM DEPARTMENT;

SELECT EMP_ID, EMP_NAME
FROM EMPLOYEE
UNION
SELECT DEPT_ID, DEPT_TITLE
FROM DEPARTMENT
UNION
SELECT JOB_CODE, JOB_NAME
FROM JOB
MINUS
SELECT EMP_ID, EMP_NAME
FROM EMPLOYEE
WHERE DEPT_CODE IN ('D5', 'D6', 'D7');

-- GROUPING SET
-- 여러 GROUP BY 절이 있는 구문을 하나로 작성하게 해주는 기능
-- 부서, 직책, 매니저별 급여평균
SELECT DEPT_CODE, JOB_CODE, MANAGER_ID, AVG(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE, JOB_CODE, MANAGER_ID;
-- 부서, 직책별 급여평균
SELECT DEPT_CODE, JOB_CODE, AVG(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE, JOB_CODE;
-- 부서, 매니저별 급여평균
SELECT DEPT_CODE, MANAGER_ID, AVG(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE, MANAGER_ID;

SELECT DEPT_CODE, JOB_CODE, MANAGER_ID, AVG(SALARY)
FROM EMPLOYEE
GROUP BY GROUPING SETS ((DEPT_CODE, JOB_CODE, MANAGER_ID), (DEPT_CODE, JOB_CODE), (DEPT_CODE, MANAGER_ID));
